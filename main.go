package main

import (
	"context"
	"fmt"
	"os"
	"os/exec"
	"strconv"
	"strings"
	"time"

	"github.com/google/go-github/v68/github"
	"github.com/sethvargo/go-githubactions"
)

func main() {
	err := run()
	if err != nil {
		fmt.Fprintf(os.Stderr, "error: %v\n", err)
		os.Exit(1)
	}
}

const emojiOK = "üü¢"
const emojiDegraded = "üî¥"
const emojiFailed = "‚ùå"

type Config struct {
	Token             string  // GitHub token with permissions to post comments
	DurationThreshold float64 // e.g. 0.1 for 10%
	MemoryThreshold   float64 // e.g. 0.1 for 10%
	AllocsThreshold   float64 // e.g. 0.1 for 10%
	BenchPattern      string  // e.g. "."
	BenchPackage      string  // e.g. "./..."
}

const commentTag = "<!-- liamg/benchmark-pr-action --> Comment generated by [liamg/go-benchmark-pr-action](https://github.com/liamg/go-benchmark-pr-action)"

func getLastCommitShort() string {
	output, err := exec.Command("git", "log", "-1", "--format=%h").Output()
	if err != nil {
		return "?"
	}
	return strings.TrimSpace(string(output))
}

func loadConfig() Config {
	config := Config{
		Token:             githubactions.GetInput("token"),
		DurationThreshold: readFloat64Input("duration_threshold", 0),
		MemoryThreshold:   readFloat64Input("memory_threshold", 0),
		AllocsThreshold:   readFloat64Input("allocs_threshold", 0),
		BenchPattern:      githubactions.GetInput("benchmark_pattern"),
		BenchPackage:      githubactions.GetInput("benchmark_package"),
	}
	githubactions.AddMask(config.Token)
	return config
}

func readFloat64Input(inputName string, defaultValue float64) float64 {

	str := githubactions.GetInput(inputName)
	if str == "" {
		return defaultValue
	}
	value, err := strconv.ParseFloat(str, 64)
	if err != nil {
		return defaultValue
	}
	return value
}

func printBenchmarks(benchmarks []Benchmark) {
	for _, benchmark := range benchmarks {
		fmt.Println(benchmark.Name)
		fmt.Printf("  Duration:    %s\n", (time.Nanosecond * time.Duration(benchmark.NsPerOp)).String())
		fmt.Printf("  Memory:      %s\n", byteCountSI(benchmark.BytesPerOp))
		fmt.Printf("  Allocations: %s\n\n", formatWithCommas(benchmark.AllocsPerOp))
	}
}

func calcPercentageChange(before, after int64, threshold float64) (float64, bool, string) {
	if before == 0 {
		if after == 0 {
			return -1, true, emojiOK
		}
		if threshold == 0 {
			return 1, true, emojiDegraded
		}
		return 1, true, emojiFailed
	}

	percentage := float64(after-before) / float64(before)

	if threshold > 0 && percentage > threshold {
		return percentage, false, emojiDegraded
	}
	if percentage > 0 {
		return percentage, false, emojiDegraded
	}
	return percentage, false, emojiOK
}

func writeRow(b strings.Builder, name, metric string, before, after int64, beforeStr, afterStr string, threshold float64) {

	percentage, infinite, emoji := calcPercentageChange(before, after, threshold)
	pcString := ""
	if infinite {
		pcString = "+‚àû%"
		if percentage < 0 {
			pcString = "-‚àû%"
		}
	} else {
		pcString = fmt.Sprintf("%.2f%%", percentage*100)
		if percentage > 0 {
			pcString = "+" + pcString
		} else if percentage == 0 {
			pcString = "-"
		}
	}

	b.WriteString(fmt.Sprintf(
		`| %s | %s | %s | %s | %s | %s |`,
		name,
		metric,
		beforeStr,
		afterStr,
		pcString,
		emoji,
	))
	b.WriteString("\n")
}

func run() error {

	config := loadConfig()

	fmt.Println("Running benchmarks on head ...")
	outputHead, err := exec.Command("go", "test", "-run=^$", "-bench="+config.BenchPattern, "-benchmem", config.BenchPackage).Output()
	if err != nil {
		return fmt.Errorf("failed to benchmark head branch: %w: %s", err, string(outputHead))
	}
	headBenchmarks := parseOutput(outputHead)
	headCommit := getLastCommitShort()

	// if not in CI, we just want some pretty results
	fmt.Println()
	fmt.Println("HEAD RESULTS")
	printBenchmarks(headBenchmarks)
	fmt.Println()

	baseBranch := "main"
	if base := os.Getenv("GITHUB_BASE_REF"); base != "" {
		baseBranch = base
	}

	// if running in CI, we want to diff etc.

	if err := exec.Command("git", "checkout", baseBranch).Run(); err != nil {
		return fmt.Errorf("failed to checkout base branch '%s': %w", baseBranch, err)
	}

	fmt.Println("Running benchmarks on", baseBranch, "...")
	outputBase, err := exec.Command("make", "benchmark").Output()
	if err != nil {
		return fmt.Errorf("failed to benchmark base branch: %w", err)
	}
	baseBenchmarks := parseOutput(outputBase)
	baseCommit := getLastCommitShort()

	fmt.Println()
	fmt.Println("BASE RESULTS")
	printBenchmarks(baseBenchmarks)
	fmt.Println()

	var fail bool
	union := unionBenchmarks(baseBenchmarks, headBenchmarks)

	if len(union) == 0 {
		fmt.Println("No benchmarks to compare.")
		return nil
	}

	var commentBuilder strings.Builder
	commentBuilder.WriteString(fmt.Sprintf("## Benchmark Results (`%s` -> `%s`)\n\n", baseCommit, headCommit))
	commentBuilder.WriteString("| Suite | Metric | Before | After | % Change | Status |\n")
	commentBuilder.WriteString("| --- | --- | --- | --- | --- | --- |\n")

	for _, benchmark := range union {

		writeRow(
			commentBuilder,
			benchmark.Head.Name,
			"Duration/Op",
			benchmark.Base.NsPerOp,
			benchmark.Head.NsPerOp,
			(time.Nanosecond * time.Duration(benchmark.Base.NsPerOp)).String(),
			(time.Nanosecond * time.Duration(benchmark.Head.NsPerOp)).String(),
			config.DurationThreshold,
		)

		writeRow(
			commentBuilder,
			benchmark.Head.Name,
			"Memory/Op",
			benchmark.Base.BytesPerOp,
			benchmark.Head.BytesPerOp,
			byteCountSI(benchmark.Base.BytesPerOp),
			byteCountSI(benchmark.Head.BytesPerOp),
			config.MemoryThreshold,
		)

		writeRow(
			commentBuilder,
			benchmark.Head.Name,
			"Allocs/Op",
			benchmark.Base.AllocsPerOp,
			benchmark.Head.AllocsPerOp,
			formatWithCommas(benchmark.Base.AllocsPerOp),
			formatWithCommas(benchmark.Head.AllocsPerOp),
			config.AllocsThreshold,
		)
	}

	commentBuilder.WriteString(commentTag)

	owner, repoName, ok := strings.Cut(os.Getenv("GITHUB_ACTION_REPOSITORY"), "/")
	if !ok {
		return fmt.Errorf("failed to parse GITHUB_ACTION_REPOSITORY")
	}

	prNumberStr, _, ok := strings.Cut(os.Getenv("GITHUB_REF_NAME"), "/")
	if !ok {
		return fmt.Errorf("failed to parse GITHUB_REF_NAME")
	}
	prNumber, err := strconv.Atoi(prNumberStr)
	if err != nil {
		return fmt.Errorf("failed to parse PR number '%s': %w", prNumberStr, err)
	}

	// post comment to PR via api
	client := github.NewClient(nil).WithAuthToken(os.Getenv("GITHUB_TOKEN"))

	comments, _, _ := client.Issues.ListComments(context.Background(), owner, repoName, prNumber, nil)
	for _, comment := range comments {
		if strings.Contains(comment.GetBody(), commentTag) {
			_, err := client.Issues.DeleteComment(context.Background(), owner, repoName, comment.GetID())
			if err != nil {
				fmt.Printf("failed to delete existing comment: %v\n", err)
			}
		}
	}

	if _, _, err := client.Issues.CreateComment(
		context.Background(),
		owner,
		repoName,
		prNumber,
		&github.IssueComment{
			Body: github.Ptr(commentBuilder.String()),
		},
	); err != nil {
		fmt.Println("failed to post comment:", err)
	}

	if fail {
		return fmt.Errorf("benchmark regression detected, see PR comment for details")
	}

	return nil
}

type Benchmark struct {
	Name        string
	Iterations  int64
	NsPerOp     int64
	BytesPerOp  int64
	AllocsPerOp int64
}

type BenchmarkDiff struct {
	Head Benchmark
	Base Benchmark
}

func unionBenchmarks(base, head []Benchmark) []BenchmarkDiff {
	var benchmarks []BenchmarkDiff
	for _, benchmark := range base {
		for _, headBenchmark := range head {
			if benchmark.Name == headBenchmark.Name {
				benchmarks = append(benchmarks, BenchmarkDiff{
					Base: benchmark,
					Head: headBenchmark,
				})
			}
		}
	}
	return benchmarks
}

func formatWithCommas(num int64) string {
	s := fmt.Sprintf("%d", num)
	n := len(s)
	if n <= 3 {
		return s
	}
	var result strings.Builder
	rem := n % 3
	if rem > 0 {
		result.WriteString(s[:rem])
		if n > rem {
			result.WriteString(",")
		}
	}
	for i := rem; i < n; i += 3 {
		result.WriteString(s[i : i+3])
		if i+3 < n {
			result.WriteString(",")
		}
	}
	return result.String()
}

func parseOutput(output []byte) []Benchmark {
	var benchmarks []Benchmark
	var err error
	for _, line := range strings.Split(string(output), "\n") {
		if !strings.HasPrefix(line, "Benchmark_") {
			continue
		}
		fields := strings.Fields(line)
		if len(fields) != 8 {
			continue
		}
		var benchmark Benchmark
		benchmark.Name = fields[0]
		benchmark.Iterations, err = strconv.ParseInt(fields[1], 10, 64)
		if err != nil {
			continue
		}
		benchmark.NsPerOp, err = strconv.ParseInt(fields[2], 10, 64)
		if err != nil {
			continue
		}
		benchmark.BytesPerOp, err = strconv.ParseInt(fields[4], 10, 64)
		if err != nil {
			continue
		}
		benchmark.AllocsPerOp, err = strconv.ParseInt(fields[6], 10, 64)
		if err != nil {
			continue
		}
		benchmarks = append(benchmarks, benchmark)
	}
	return benchmarks
}

func byteCountSI(b int64) string {
	const unit = 1000
	if b < unit {
		return fmt.Sprintf("%d B", b)
	}
	div, exp := int64(unit), 0
	for n := b / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}
	return fmt.Sprintf("%.1f %cB",
		float64(b)/float64(div), "kMGTPE"[exp])
}
