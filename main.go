package main

import (
	"context"
	"encoding/json"
	"fmt"
	"math"
	"os"
	"os/exec"
	"strconv"
	"strings"
	"time"

	"github.com/google/go-github/v68/github"
	"github.com/sethvargo/go-githubactions"
)

func main() {
	err := run()
	if err != nil {
		fmt.Fprintf(os.Stderr, "error: %v\n", err)
		os.Exit(1)
	}
}

const emojiOK = "üü¢"
const emojiSlight = "üü°"
const emojiDegraded = "üî¥"
const emojiFailed = "‚ùå"

type Config struct {
	Token             string  // GitHub token with permissions to post comments
	DurationThreshold float64 // e.g. 0.1 for 10%
	MemoryThreshold   float64 // e.g. 0.1 for 10%
	AllocsThreshold   float64 // e.g. 0.1 for 10%
	BenchPattern      string  // e.g. "."
	BenchPackage      string  // e.g. "./..."
	BenchSeconds      int     // e.g. 1
}

const commentTag = "<!-- liamg/benchmark-pr-action -->"
const commentGen = "Comment generated by [liamg/go-benchmark-pr-action](https://github.com/liamg/go-benchmark-pr-action)"

func getLastCommitShort() string {
	output, err := exec.Command("git", "log", "-1", "--format=%h").Output()
	if err != nil {
		return "?"
	}
	return strings.TrimSpace(string(output))
}

func loadConfig() Config {
	config := Config{
		Token:             githubactions.GetInput("token"),
		DurationThreshold: readFloat64Input("duration_threshold", 0) / 100,
		MemoryThreshold:   readFloat64Input("memory_threshold", 0) / 100,
		AllocsThreshold:   readFloat64Input("allocs_threshold", 0) / 100,
		BenchPattern:      githubactions.GetInput("benchmark_pattern"),
		BenchPackage:      githubactions.GetInput("benchmark_package"),
		BenchSeconds:      readIntInput("benchmark_seconds", 1),
	}
	githubactions.AddMask(config.Token)
	return config
}

func readIntInput(inputName string, defaultValue int) int {
	str := githubactions.GetInput(inputName)
	if str == "" {
		return defaultValue
	}
	value, err := strconv.Atoi(str)
	if err != nil {
		return defaultValue
	}
	return value
}

func readFloat64Input(inputName string, defaultValue float64) float64 {

	str := githubactions.GetInput(inputName)
	if str == "" {
		return defaultValue
	}
	value, err := strconv.ParseFloat(str, 64)
	if err != nil {
		return defaultValue
	}
	return value
}

func printBenchmarks(benchmarks []Benchmark) {
	for _, benchmark := range benchmarks {
		fmt.Println(benchmark.Name)
		fmt.Printf("  Duration:    %s\n", (time.Nanosecond * time.Duration(benchmark.NsPerOp)).String())
		fmt.Printf("  Memory:      %s\n", byteCountSI(benchmark.BytesPerOp))
		fmt.Printf("  Allocations: %s\n\n", formatWithCommas(benchmark.AllocsPerOp))
	}
}

func calcPercentageChange(before, after int64, threshold float64) (float64, bool, string) {
	if before == 0 {
		if after == 0 {
			return -1, true, emojiOK
		}
		if threshold == 0 {
			return 1, true, emojiDegraded
		}
		return 1, true, emojiFailed
	}

	percentage := float64(after-before) / float64(before)

	// round to 2dp
	percentage = math.Round(percentage*100) / 100

	if threshold > 0 && percentage > threshold && percentage-threshold > 0.00001 {
		return percentage, false, emojiDegraded
	}
	if percentage > 0 {
		if percentage <= 0.05 {
			return percentage, false, emojiSlight
		}
		return percentage, false, emojiDegraded
	}
	return percentage, false, emojiOK
}

func runCommand(command ...string) (string, error) {
	if len(command) == 0 {
		return "", fmt.Errorf("no command provided")
	}
	output, err := exec.Command(command[0], command[1:]...).CombinedOutput()
	if err != nil {
		return "", fmt.Errorf("failed to run command [%s]: %w: %s", strings.Join(command, " "), err, string(output))
	}
	return string(output), nil
}

func writeRow(b *strings.Builder, name, metric string, before, after int64, beforeStr, afterStr string, threshold float64) {

	percentage, infinite, emoji := calcPercentageChange(before, after, threshold)
	pcString := ""
	if infinite {
		pcString = "+‚àû%"
		if percentage < 0 {
			pcString = "-‚àû%"
		}
	} else {
		pcString = fmt.Sprintf("%.2f%%", percentage*100)
		if percentage > 0 {
			pcString = "+" + pcString
		} else if percentage == 0 {
			pcString = "_same_"
		}
	}

	b.WriteString(fmt.Sprintf(
		`| %s | %s | %s | %s | %s | %s |`,
		name,
		metric,
		beforeStr,
		afterStr,
		pcString,
		emoji,
	))
	b.WriteString("\n")
}

func runBenchmarks(config Config) ([]Benchmark, error) {
	output, err := exec.Command("go", "test", "-run=^$", "-bench="+config.BenchPattern, "-benchmem", config.BenchPackage, "-benchtime", fmt.Sprintf("%ds", config.BenchSeconds)).Output()
	if err != nil {
		return nil, fmt.Errorf("benchmark error: %w: %s", err, string(output))
	}
	fmt.Println(string(output))
	return parseOutput(output), nil
}

type githubEvent struct {
	HeadRefName string `json:"ref_name"`
	PullRequest struct {
		Head struct {
			Sha string `json:"sha"`
		} `json:"head"`
	} `json:"pull_request"`
}

func getGithubEvent() (*githubEvent, error) {
	if eventPath := os.Getenv("GITHUB_EVENT_PATH"); eventPath != "" {
		if data, err := os.ReadFile(eventPath); err == nil {
			var event githubEvent
			if err := json.Unmarshal(data, &event); err == nil {
				return &event, nil
			}
		}
	}
	return nil, fmt.Errorf("failed to get github event")
}

func run() error {

	baseBranch := "main"
	if base := os.Getenv("GITHUB_BASE_REF"); base != "" {
		baseBranch = base
	}

	config := loadConfig()
	event, err := getGithubEvent()
	if err != nil {
		return fmt.Errorf("failed to read github event: %w", err)
	}

	if event.HeadRefName == baseBranch {
		fmt.Println("Skipping benchmarking, this should only be used for PR events")
		return nil
	}

	headCommit := event.PullRequest.Head.Sha
	if len(headCommit) < 7 {
		return fmt.Errorf("invalid head commit: %s", headCommit)
	}
	headCommit = headCommit[:7]

	fmt.Println("Running benchmarks on head ...")
	headBenchmarks, err := runBenchmarks(config)
	if err != nil {
		return fmt.Errorf("failed to run benchmarks on head: %w", err)
	}

	// if not in CI, we just want some pretty results
	fmt.Println()
	fmt.Println("HEAD RESULTS")
	printBenchmarks(headBenchmarks)
	fmt.Println()

	owner, repoName, ok := strings.Cut(os.Getenv("GITHUB_REPOSITORY"), "/")
	if !ok {
		return fmt.Errorf("failed to parse GITHUB_REPOSITORY")
	}

	wd, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("failed to get working directory: %w", err)
	}

	if _, err := runCommand("git", "config", "--global", "--add", "safe.directory", wd); err != nil {
		return fmt.Errorf("failed to set safe.directory: %w", err)

	}

	if _, err := runCommand("git", "-c", "protocol.version=2", "fetch", "--no-tags", "--prune", "--no-recurse-submodules", "--depth=1", "origin", "+"+baseBranch+":refs/remotes/base"); err != nil {
		return fmt.Errorf("failed to fetch base branch '%s': %w", baseBranch, err)
	}
	if _, err := runCommand("git", "checkout", "--force", "refs/remotes/base"); err != nil {
		return fmt.Errorf("failed to checkout base branch '%s': %w", baseBranch, err)
	}

	fmt.Println("Running benchmarks on", baseBranch, "...")
	baseBenchmarks, err := runBenchmarks(config)
	if err != nil {
		return fmt.Errorf("failed to run benchmarks on head: %w", err)
	}
	baseCommit := getLastCommitShort()

	fmt.Println()
	fmt.Println("BASE RESULTS")
	printBenchmarks(baseBenchmarks)
	fmt.Println()

	var fail bool
	union := unionBenchmarks(baseBenchmarks, headBenchmarks)

	if len(union) == 0 {
		fmt.Println("No benchmarks to compare.")
		return nil
	}

	var commentBuilder strings.Builder
	commentBuilder.WriteString(fmt.Sprintf("## Benchmark Results (`%s` -> `%s`)\n\n", baseCommit, headCommit))
	commentBuilder.WriteString("| Suite | Metric | Before | After | % Change | Status |\n")
	commentBuilder.WriteString("| --- | --- | --- | --- | --- | --- |\n")

	for _, benchmark := range union {

		writeRow(
			&commentBuilder,
			benchmark.Head.Name,
			"Duration/Op",
			benchmark.Base.NsPerOp,
			benchmark.Head.NsPerOp,
			(time.Nanosecond * time.Duration(benchmark.Base.NsPerOp)).String(),
			(time.Nanosecond * time.Duration(benchmark.Head.NsPerOp)).String(),
			config.DurationThreshold,
		)

		writeRow(
			&commentBuilder,
			benchmark.Head.Name,
			"Memory/Op",
			benchmark.Base.BytesPerOp,
			benchmark.Head.BytesPerOp,
			byteCountSI(benchmark.Base.BytesPerOp),
			byteCountSI(benchmark.Head.BytesPerOp),
			config.MemoryThreshold,
		)

		writeRow(
			&commentBuilder,
			benchmark.Head.Name,
			"Allocs/Op",
			benchmark.Base.AllocsPerOp,
			benchmark.Head.AllocsPerOp,
			formatWithCommas(benchmark.Base.AllocsPerOp),
			formatWithCommas(benchmark.Head.AllocsPerOp),
			config.AllocsThreshold,
		)
	}

	commentBuilder.WriteString(commentTag + "\n")
	commentBuilder.WriteString(commentGen + "\n")

	prNumberStr, _, ok := strings.Cut(os.Getenv("GITHUB_REF_NAME"), "/")
	if !ok {
		return fmt.Errorf("failed to parse GITHUB_REF_NAME")
	}
	prNumber, err := strconv.Atoi(prNumberStr)
	if err != nil {
		return fmt.Errorf("failed to parse PR number '%s': %w", prNumberStr, err)
	}

	// post comment to PR via api
	client := github.NewClient(nil).WithAuthToken(config.Token)

	var commented bool
	comments, _, _ := client.Issues.ListComments(context.Background(), owner, repoName, prNumber, nil)
	for _, comment := range comments {
		if strings.Contains(comment.GetBody(), commentTag) {
			if _, _, err := client.Issues.EditComment(context.Background(), owner, repoName, comment.GetID(), &github.IssueComment{
				Body: github.Ptr(commentBuilder.String()),
			}); err != nil {
				fmt.Println("failed to edit comment:", err)
			} else {
				commented = true
			}
			break
		}
	}

	if !commented {
		if _, _, err := client.Issues.CreateComment(
			context.Background(),
			owner,
			repoName,
			prNumber,
			&github.IssueComment{
				Body: github.Ptr(commentBuilder.String()),
			},
		); err != nil {
			fmt.Println("failed to post comment:", err)
		}
	}

	if fail {
		return fmt.Errorf("benchmark regression detected, see PR comment for details")
	}

	return nil
}

type Benchmark struct {
	Name        string
	Iterations  int64
	NsPerOp     int64
	BytesPerOp  int64
	AllocsPerOp int64
}

type BenchmarkDiff struct {
	Head Benchmark
	Base Benchmark
}

func unionBenchmarks(base, head []Benchmark) []BenchmarkDiff {
	var benchmarks []BenchmarkDiff
	for _, benchmark := range base {
		for _, headBenchmark := range head {
			if benchmark.Name == headBenchmark.Name {
				benchmarks = append(benchmarks, BenchmarkDiff{
					Base: benchmark,
					Head: headBenchmark,
				})
			}
		}
	}
	return benchmarks
}

func formatWithCommas(num int64) string {
	s := fmt.Sprintf("%d", num)
	n := len(s)
	if n <= 3 {
		return s
	}
	var result strings.Builder
	rem := n % 3
	if rem > 0 {
		result.WriteString(s[:rem])
		if n > rem {
			result.WriteString(",")
		}
	}
	for i := rem; i < n; i += 3 {
		result.WriteString(s[i : i+3])
		if i+3 < n {
			result.WriteString(",")
		}
	}
	return result.String()
}

func parseOutput(output []byte) []Benchmark {
	var benchmarks []Benchmark
	var err error
	for _, line := range strings.Split(string(output), "\n") {
		if !strings.HasPrefix(line, "Benchmark_") {
			continue
		}
		fields := strings.Fields(line)
		if len(fields) != 8 {
			continue
		}
		var benchmark Benchmark
		benchmark.Name = fields[0]
		benchmark.Iterations, err = strconv.ParseInt(fields[1], 10, 64)
		if err != nil {
			continue
		}
		benchmark.NsPerOp, err = strconv.ParseInt(fields[2], 10, 64)
		if err != nil {
			continue
		}
		benchmark.BytesPerOp, err = strconv.ParseInt(fields[4], 10, 64)
		if err != nil {
			continue
		}
		benchmark.AllocsPerOp, err = strconv.ParseInt(fields[6], 10, 64)
		if err != nil {
			continue
		}
		benchmarks = append(benchmarks, benchmark)
	}
	return benchmarks
}

func byteCountSI(b int64) string {
	const unit = 1000
	if b < unit {
		return fmt.Sprintf("%d B", b)
	}
	div, exp := int64(unit), 0
	for n := b / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}
	return fmt.Sprintf("%.1f %cB",
		float64(b)/float64(div), "kMGTPE"[exp])
}
