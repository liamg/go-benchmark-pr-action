package main

import (
	"context"
	"encoding/json"
	"fmt"
	"math"
	"os"
	"os/exec"
	"strconv"
	"strings"
	"time"

	"github.com/google/go-github/v68/github"
	"github.com/sethvargo/go-githubactions"
)

func main() {
	err := run()
	if err != nil {
		fmt.Fprintf(os.Stderr, "error: %v\n", err)
		os.Exit(1)
	}
}

const emojiOK = "üü¢"
const emojiSlight = "üü°"
const emojiDegraded = "üî¥"
const emojiFailed = "‚ùå"

type Config struct {
	Token             string  // GitHub token with permissions to post comments
	DurationThreshold float64 // e.g. 0.1 for 10%
	MemoryThreshold   float64 // e.g. 0.1 for 10%
	AllocsThreshold   float64 // e.g. 0.1 for 10%
	BenchPattern      string  // e.g. "."
	BenchPackage      string  // e.g. "./..."
	BenchSeconds      int     // e.g. 1
	BenchCount        int     // e.g. 0
}

const commentTag = "<!-- liamg/benchmark-pr-action -->"
const commentGen = "Comment generated by [liamg/go-benchmark-pr-action](https://github.com/liamg/go-benchmark-pr-action)"

func getLastCommitShort() string {
	output, err := exec.Command("git", "log", "-1", "--format=%h").Output()
	if err != nil {
		return "?"
	}
	return strings.TrimSpace(string(output))
}

func loadConfig() Config {
	config := Config{
		Token:             githubactions.GetInput("token"),
		DurationThreshold: readFloat64Input("duration_threshold", 0) / 100,
		MemoryThreshold:   readFloat64Input("memory_threshold", 0) / 100,
		AllocsThreshold:   readFloat64Input("allocs_threshold", 0) / 100,
		BenchPattern:      githubactions.GetInput("benchmark_pattern"),
		BenchPackage:      githubactions.GetInput("benchmark_package"),
		BenchSeconds:      readIntInput("benchmark_seconds", 1),
		BenchCount:        readIntInput("benchmark_count", 0),
	}
	githubactions.AddMask(config.Token)
	return config
}

func readIntInput(inputName string, defaultValue int) int {
	str := githubactions.GetInput(inputName)
	if str == "" {
		return defaultValue
	}
	value, err := strconv.Atoi(str)
	if err != nil {
		return defaultValue
	}
	return value
}

func readFloat64Input(inputName string, defaultValue float64) float64 {

	str := githubactions.GetInput(inputName)
	if str == "" {
		return defaultValue
	}
	value, err := strconv.ParseFloat(str, 64)
	if err != nil {
		return defaultValue
	}
	return value
}

func printBenchmarks(benchmarks []Benchmark) {
	for _, benchmark := range benchmarks {
		fmt.Println(benchmark.Name)
		fmt.Printf("  Duration:    %s\n", (time.Nanosecond * time.Duration(benchmark.NsPerOp)).String())
		fmt.Printf("  Memory:      %s\n", byteCountSI(benchmark.BytesPerOp))
		fmt.Printf("  Allocations: %s\n\n", formatWithCommas(benchmark.AllocsPerOp))
	}
}

func calcPercentageChange(before, after int64, threshold float64) (float64, bool, string) {
	if before == 0 {
		if after == 0 {
			return -1, true, emojiOK
		}
		if threshold == 0 {
			return 1, true, emojiDegraded
		}
		return 1, true, emojiFailed
	}

	percentage := float64(after-before) / float64(before)

	// round to 2dp
	percentage = math.Round(percentage*10000) / 10000

	if threshold > 0 && percentage > threshold && percentage-threshold > 0.00001 {
		return percentage, false, emojiDegraded
	}
	if percentage > 0.0005 {
		if percentage <= 0.05 {
			return percentage, false, emojiSlight
		}
		return percentage, false, emojiDegraded
	}
	return percentage, false, emojiOK
}

func runCommand(command ...string) (string, error) {
	if len(command) == 0 {
		return "", fmt.Errorf("no command provided")
	}
	output, err := exec.Command(command[0], command[1:]...).CombinedOutput()
	if err != nil {
		return "", fmt.Errorf("failed to run command [%s]: %w: %s", strings.Join(command, " "), err, string(output))
	}
	return string(output), nil
}

func writeRow(b *strings.Builder, name, metric string, before, after int64, beforeStr, afterStr string, threshold float64, includeDiff bool) {

	var pcString string
	var emoji string

	if includeDiff {
		var percentage float64
		var infinite bool
		percentage, infinite, emoji = calcPercentageChange(before, after, threshold)
		if infinite {
			pcString = "+‚àû%"
			if percentage < 0 {
				pcString = "-‚àû%"
			}
		} else {
			pcString = fmt.Sprintf("%.2f%%", percentage*100)
			if percentage > 0.0005 { // ignore <0.05% increase, this seems to vary generally with each build
				pcString = "+" + pcString
			} else if percentage >= 0 {
				pcString = "_same_"
			}
		}
	} else {
		pcString = "-"
		emoji = "emojiOK"

	}

	b.WriteString(fmt.Sprintf(
		`| %s | %s | %s | %s | %s | %s |`,
		name,
		metric,
		beforeStr,
		afterStr,
		pcString,
		emoji,
	))
	b.WriteString("\n")
}

func runBenchmarks(config Config) ([]Benchmark, error) {
	args := []string{"test", "-run=^$", "-bench=" + config.BenchPattern, "-benchmem", config.BenchPackage, "-benchtime", fmt.Sprintf("%ds", config.BenchSeconds)}
	if config.BenchCount > 0 {
		args = append(args, fmt.Sprintf("-count=%d", config.BenchCount))
	}
	fmt.Println("Running: go", strings.Join(args, " "))
	output, err := exec.Command("go", args...).Output()
	if err != nil {
		return nil, fmt.Errorf("benchmark error: %w: %s", err, string(output))
	}
	fmt.Println(string(output))
	return parseOutput(output), nil
}

type githubEvent struct {
	HeadRefName string `json:"ref_name"`
	PullRequest struct {
		Head struct {
			Sha string `json:"sha"`
		} `json:"head"`
	} `json:"pull_request"`
}

func getGithubEvent() (*githubEvent, error) {
	if eventPath := os.Getenv("GITHUB_EVENT_PATH"); eventPath != "" {
		if data, err := os.ReadFile(eventPath); err == nil {
			var event githubEvent
			if err := json.Unmarshal(data, &event); err == nil {
				return &event, nil
			}
		}
	}
	return nil, fmt.Errorf("failed to get github event")
}

func run() error {

	baseBranch := "main"
	if base := os.Getenv("GITHUB_BASE_REF"); base != "" {
		baseBranch = base
	}

	config := loadConfig()
	event, err := getGithubEvent()
	if err != nil {
		return fmt.Errorf("failed to read github event: %w", err)
	}

	if event.HeadRefName == baseBranch {
		fmt.Println("Skipping benchmarking, this should only be used for PR events")
		return nil
	}

	headCommit := event.PullRequest.Head.Sha
	if len(headCommit) < 7 {
		return fmt.Errorf("invalid head commit: %s", headCommit)
	}
	headCommit = headCommit[:7]

	fmt.Println("Running benchmarks on head ...")
	start := time.Now()
	headBenchmarks, err := runBenchmarks(config)
	if err != nil {
		return fmt.Errorf("failed to run benchmarks on head: %w", err)
	}
	fmt.Println("Took", time.Since(start))

	// if not in CI, we just want some pretty results
	fmt.Println()
	fmt.Println("HEAD RESULTS")
	printBenchmarks(headBenchmarks)
	fmt.Println()

	owner, repoName, ok := strings.Cut(os.Getenv("GITHUB_REPOSITORY"), "/")
	if !ok {
		return fmt.Errorf("failed to parse GITHUB_REPOSITORY")
	}

	wd, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("failed to get working directory: %w", err)
	}

	if _, err := runCommand("git", "config", "--global", "--add", "safe.directory", wd); err != nil {
		return fmt.Errorf("failed to set safe.directory: %w", err)

	}

	if _, err := runCommand("git", "-c", "protocol.version=2", "fetch", "--no-tags", "--prune", "--no-recurse-submodules", "--depth=1", "origin", "+"+baseBranch+":refs/remotes/base"); err != nil {
		return fmt.Errorf("failed to fetch base branch '%s': %w", baseBranch, err)
	}
	if _, err := runCommand("git", "checkout", "--force", "refs/remotes/base"); err != nil {
		return fmt.Errorf("failed to checkout base branch '%s': %w", baseBranch, err)
	}

	fmt.Println("Running benchmarks on", baseBranch, "...")
	start = time.Now()
	baseBenchmarks, err := runBenchmarks(config)
	if err != nil {
		fmt.Println("Failed to run benchmarks on base branch, skipping checks:", err)
		return nil
	}
	fmt.Println("Took", time.Since(start))
	baseCommit := getLastCommitShort()

	fmt.Println()
	fmt.Println("BASE RESULTS")
	printBenchmarks(baseBenchmarks)
	fmt.Println()

	var fail bool
	diffed := compareBenchmarks(baseBenchmarks, headBenchmarks)

	if len(diffed) == 0 {
		fmt.Println("No benchmarks to compare.")
		return nil
	}

	byPackage := benchmarksByPackage(diffed)

	var commentBuilder strings.Builder
	commentBuilder.WriteString(fmt.Sprintf("## Benchmark Results (`%s` -> `%s`)\n\n", baseCommit, headCommit))

	for _, benchmarks := range byPackage {

		commentBuilder.WriteString(fmt.Sprintf("### %s\n", benchmarks[0].Head.Package))
		commentBuilder.WriteString("\n")
		commentBuilder.WriteString(fmt.Sprintf("CPU: `%s`\n", benchmarks[0].Head.CPU))
		commentBuilder.WriteString("\n")
		commentBuilder.WriteString("| Suite | Metric | Before | After | % Change | Status |\n")
		commentBuilder.WriteString("| --- | --- | --- | --- | --- | --- |\n")

		for _, benchmark := range benchmarks {

			name := ""
			if benchmark.Base != nil {
				name = benchmark.Base.Name
			} else if benchmark.Head != nil {
				name = benchmark.Head.Name
			}

			{
				// duration
				var before, after int64
				var beforeStr, afterStr string
				if benchmark.Base != nil {
					before = benchmark.Base.NsPerOp
					beforeStr = (time.Nanosecond * time.Duration(benchmark.Base.NsPerOp)).String()
				} else {
					beforeStr = "_added_"
				}
				if benchmark.Head != nil {
					after = benchmark.Head.NsPerOp
					afterStr = (time.Nanosecond * time.Duration(benchmark.Head.NsPerOp)).String()
				} else {
					afterStr = "_removed_"
				}

				writeRow(
					&commentBuilder,
					name,
					"Duration/Op",
					before,
					after,
					beforeStr,
					afterStr,
					config.DurationThreshold,
					benchmark.Base != nil && benchmark.Head != nil,
				)
			}

			{
				// memory
				var before, after int64
				var beforeStr, afterStr string
				if benchmark.Base != nil {
					before = benchmark.Base.BytesPerOp
					beforeStr = byteCountSI(benchmark.Base.BytesPerOp)
				} else {
					beforeStr = "_added_"
				}
				if benchmark.Head != nil {
					after = benchmark.Head.BytesPerOp
					afterStr = byteCountSI(benchmark.Head.BytesPerOp)
				} else {
					afterStr = "_removed_"
				}

				writeRow(
					&commentBuilder,
					name,
					"Memory/Op",
					before,
					after,
					beforeStr,
					afterStr,
					config.MemoryThreshold,
					benchmark.Base != nil && benchmark.Head != nil,
				)
			}

			{
				// allocs
				var before, after int64
				var beforeStr, afterStr string
				if benchmark.Base != nil {
					before = benchmark.Base.AllocsPerOp
					beforeStr = formatWithCommas(benchmark.Base.AllocsPerOp)
				} else {
					beforeStr = "_added_"
				}
				if benchmark.Head != nil {
					after = benchmark.Head.AllocsPerOp
					afterStr = formatWithCommas(benchmark.Head.AllocsPerOp)
				} else {
					afterStr = "_removed_"
				}
				writeRow(
					&commentBuilder,
					name,
					"Allocs/Op",
					before,
					after,
					beforeStr,
					afterStr,
					config.AllocsThreshold,
					benchmark.Base != nil && benchmark.Head != nil,
				)
			}
		}

		commentBuilder.WriteString("\n")
	}

	commentBuilder.WriteString(commentTag + "\n")
	commentBuilder.WriteString(commentGen + "\n")

	prNumberStr, _, ok := strings.Cut(os.Getenv("GITHUB_REF_NAME"), "/")
	if !ok {
		return fmt.Errorf("failed to parse GITHUB_REF_NAME")
	}
	prNumber, err := strconv.Atoi(prNumberStr)
	if err != nil {
		return fmt.Errorf("failed to parse PR number '%s': %w", prNumberStr, err)
	}

	// post comment to PR via api
	client := github.NewClient(nil).WithAuthToken(config.Token)

	var commented bool
	comments, _, _ := client.Issues.ListComments(context.Background(), owner, repoName, prNumber, nil)
	for _, comment := range comments {
		if strings.Contains(comment.GetBody(), commentTag) {
			if _, _, err := client.Issues.EditComment(context.Background(), owner, repoName, comment.GetID(), &github.IssueComment{
				Body: github.Ptr(commentBuilder.String()),
			}); err != nil {
				fmt.Println("failed to edit comment:", err)
			} else {
				commented = true
			}
			break
		}
	}

	if !commented {
		if _, _, err := client.Issues.CreateComment(
			context.Background(),
			owner,
			repoName,
			prNumber,
			&github.IssueComment{
				Body: github.Ptr(commentBuilder.String()),
			},
		); err != nil {
			fmt.Println("failed to post comment:", err)
		}
	}

	if fail {
		return fmt.Errorf("benchmark regression detected, see PR comment for details")
	}

	return nil
}

type Benchmark struct {
	CPU         string
	Package     string
	Name        string
	Iterations  int64
	NsPerOp     int64
	BytesPerOp  int64
	AllocsPerOp int64
}

type BenchmarkDiff struct {
	Head *Benchmark
	Base *Benchmark
}

func compareBenchmarks(base, head []Benchmark) []BenchmarkDiff {
	var benchmarks []BenchmarkDiff
	for _, benchmark := range base {
		var found bool
		for _, headBenchmark := range head {
			if benchmark.Name == headBenchmark.Name && benchmark.Package == headBenchmark.Package {
				benchmarks = append(benchmarks, BenchmarkDiff{
					Base: &benchmark,
					Head: &headBenchmark,
				})
				found = true
				break
			}
		}
		if !found {
			benchmarks = append(benchmarks, BenchmarkDiff{
				Base: &benchmark,
				Head: nil,
			})
		}
	}
	for _, benchmark := range head {
		var found bool
		for _, baseBenchmark := range base {
			if benchmark.Name == baseBenchmark.Name && benchmark.Package == baseBenchmark.Package {
				found = true
				break
			}
		}
		if !found {
			benchmarks = append(benchmarks, BenchmarkDiff{
				Base: nil,
				Head: &benchmark,
			})
		}
	}
	return benchmarks
}

func benchmarksByPackage(benchmarks []BenchmarkDiff) map[string][]BenchmarkDiff {
	packages := make(map[string][]BenchmarkDiff)
	for _, benchmark := range benchmarks {
		pkg := ""
		if benchmark.Head != nil {
			pkg = benchmark.Head.Package
		} else if benchmark.Base != nil {
			pkg = benchmark.Base.Package
		}
		packages[pkg] = append(packages[pkg], benchmark)
	}
	return packages
}

func formatWithCommas(num int64) string {
	s := fmt.Sprintf("%d", num)
	n := len(s)
	if n <= 3 {
		return s
	}
	var result strings.Builder
	rem := n % 3
	if rem > 0 {
		result.WriteString(s[:rem])
		if n > rem {
			result.WriteString(",")
		}
	}
	for i := rem; i < n; i += 3 {
		result.WriteString(s[i : i+3])
		if i+3 < n {
			result.WriteString(",")
		}
	}
	return result.String()
}

func parseOutput(output []byte) []Benchmark {
	var benchmarks []Benchmark
	var err error
	var pkg string
	var cpu string
	for _, line := range strings.Split(string(output), "\n") {
		if strings.HasPrefix(line, "pkg:") {
			if fields := strings.Fields(line); len(fields) > 1 {
				pkg = fields[1]
			}
			continue
		}
		if strings.HasPrefix(line, "cpu:") {
			if fields := strings.Fields(line); len(fields) > 1 {
				cpu = strings.Join(fields[1:], " ")
			}
			continue
		}
		if !strings.HasPrefix(line, "Benchmark_") {
			continue
		}
		fields := strings.Fields(line)
		if len(fields) != 8 {
			continue
		}
		var benchmark Benchmark
		benchmark.Name = fields[0]
		benchmark.Package = pkg
		benchmark.CPU = cpu
		benchmark.Iterations, err = strconv.ParseInt(fields[1], 10, 64)
		if err != nil {
			continue
		}
		benchmark.NsPerOp, err = strconv.ParseInt(fields[2], 10, 64)
		if err != nil {
			continue
		}
		benchmark.BytesPerOp, err = strconv.ParseInt(fields[4], 10, 64)
		if err != nil {
			continue
		}
		benchmark.AllocsPerOp, err = strconv.ParseInt(fields[6], 10, 64)
		if err != nil {
			continue
		}
		benchmarks = append(benchmarks, benchmark)
	}
	return benchmarks
}

func byteCountSI(b int64) string {
	const unit = 1000
	if b < unit {
		return fmt.Sprintf("%d B", b)
	}
	div, exp := int64(unit), 0
	for n := b / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}
	return fmt.Sprintf("%.1f %cB",
		float64(b)/float64(div), "kMGTPE"[exp])
}
